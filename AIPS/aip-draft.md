<pre>
  AIP: unassigned
  Title: Providing PoW like guarantees on (D)PoS networks
  Authors: Moazzam Abdullah Khan, Asif Mehmood
  Status: Draft
  Type: Standards Track
  Created: 2018-12-08
  Last Update: 2018-12-08
</pre>

Note: This document is a WIP.

Abstract
========

Traditional Proof of Stake (PoS) and Delegated Proof of Stake (DPoS) approaches achieve Probabilistic Byzantine Fault Tolerant consensus without creating the race condidtion that Proof of Work (PoW) systems create. As a result these approaches waste less energy and therefore are able to provide utility at a cheaper cost. However one drawback of conventional (D)PoS approaches is that they cannot guarantee data immutability as a result of predictable hash sequences or easy re-sync guarantees by accepting only the longest chain as valid. This proposal aims to address these concerns by introducing an approach to determine producer of the next block while keeping them hidden until the block is actually announced. This enables strong guarantees that the data is immutable and that the next block's forger isn't known to the network beforehand thereby eliminatng a DDoS attack vector.


Motivation
==========

As cryptocurrencies get used more widely it is desired that the infrastructure and algorithms required to deploy them become more cost efficient so that barriers to entry for aspiring developers and dapp creators are reduced. This desire has given rise to PoS and DPoS paradigms which achieve the same level of concensus as PoW systems at several orders of magnitude lower cost. However these (D)PoS systems don't provide a hard guarantee that data committed to the blockchain cannot be changed. As a result (D)PoS systems cannot take advantage of the longest chain valid principle that creates concensus in PoW systems because doing would make them vulnerable to deep reorg attacks. This kind of attack is undetectable in current schemes and is pretty cheap to carry out. Because of this failure there is no easy way to trust data provided by other nodes and local backups of the blockchain have to be relied upon for a guarantee that the data has not been changed for older blocks. These are critical issues that need to be addressed and one approach that we can take to solve them is discussed below. This proposal will describe the approach in context to Ark but it can be applied to any Proof of Stake system.


Rationale
=========

The main emphasis in this approach is to create a verifiable random function (VRF) that is used to generate random numbers. This allows us to select the next block producer using the generated random number. This is achieved by making each delegate submit a pledge containing the hash of a secret random number. If the random number generated by the VRF is concurrent with the pledged secret submitted by a delegate then that particular delegate is allowed to create the next block. While creating the new block the delegate will add the secret random number as claim corresponding to the colliding pledge as proof for other delegates to validate their claim of having the right to produce the block.

One issue that must be pointed out while working with VRF implementations is the last actor problem which is a situation in which the latest block producer can keep producing blocks and discarding them until they have found one that confirms themself to be the next block producer as well. In order to circumvent the issue altogether we mandate that the VRF is created from blocks at least N depth away from current height H of the blockchain where N is the total number of forging delegates.

1. Bootstrapping process
	* Randomized Round robin for 2 rounds using current approach implemented by the Ark v2 protocol
	* During this round with each block the producer of the block commits the sha256 hash of a string containing a large secret number and time epoch to the blockchain via a special pledge transaction (discussed below)
	
2. Creating the VRF
	* The hashes pledged by the delegates in the blocks from depth N to 2*N from current block height H are collected and concatenated into a string. This string is then hashed using sha256 to create the new random number.  Using this approach all N delegates get an equal chance to contribute to the VRF's next output and there is no chance for hijacking the random number generator by a minority of colluding parties.
	
3. Selecting Next Blockproducer
	* The new random number generated is modded by a number C smaller than N
	* Each delegate mods their secret number by C as well
	* If both of these resulting numbers match for a delegate then that delegate has the right to forge next block
	* Other nodes will only accept block produced for which the claim correlates to the earliest unused pledge and will reject claim with a later pledge committed in a later block


Specifications
==============


```
inputs:
N = number of delegates (or minimum number of PoS miners);
integer C less than N;

algorithm:
rand = random.next()
public_rand = f_privateKey(rand) = (rand)^privateKey
if no_active_pledge:
publish_pledge_tx(public_rand)

for all unused pledges by delegate:
{
	if H > 2*N:
	{
		j = sha256( concatenate_hashes_from_height(H-N, H-2*N) ) % C
		if rand%C == j:
		{
			create_next_block()
		}
		
	}
	else
	{
		follow_old_algorithm()
	}
}
```